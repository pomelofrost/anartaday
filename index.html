<!DOCTYPE html>
<html>
    <head>
        <title>ART?</title>
        <style>
            body{margin: 0;}
            canvas {width: 100%; height: 100%;}
        
        </style>
    </head>
    <body>
        <meta charset="utf-8">
        <meta name="keywords" content="The Met, museum, art">
        <link rel= "stylesheet" type="text/css" href='style.css'>
        <link rel="stylesheet" href="https://use.typekit.net/fzn4xnk.css">
        <script type="text/javascript" src="js/jquery-3.4.0.min.js"></script>
        <script>
          $(document).ready(function(){
                $("#go").click(function(){
                    $(".main-wrapper").addClass("hide");               
                })
           });
        
          $(document).ready(function(){
                $("#go").click(function(){
                    $(".rect").addClass("hide");               
                })
           });
        </script>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/GLTFLoader.js"></script>
<!--
        <header>
           <nav>
                <ul>
                    <li>
                        <a href="index.html">Home</a>
                    </li>
                    <li>
                        <a href="about.html">Explore</a>
                    </li>
                    <li>
                        <a href="contact.html">About</a>
                    </li>
                </ul>
            </nav>
            <div class="clear"></div>
        </header>
-->
        <div class="main-wrapper wrapper">
            <div class="row">
               <div class="med-hide lrg-c2"></div>
               <div class="content content-centered">
                 <img src="img/logo.png">
                 <h1 class="page-title">One Art Per Day</h1>
                 <div class="container sub-content">
                     <p>We’d like to create a virtual museum space that allows users to discover different pieces of art in a hyper-focused or personalized way. Tentatively, works of art pulled from the Met API will be displayed in a 3D immersive experience using three.js, and users will be presented to the ability to learn more about the work of art in this “room” or discover and keep track of similar pieces they like.
                    </p>
                    <div>
                       <a href="#" class="go" id="go">Start Exploring</a>
                    </div> 
                    <footer class="global-footer">
                       <div class="global-footer_wrapper">
<!--
                           <div class="global-footer_copyright">
                                <p>Created by Allissa Chan, Sharon Lee, and Sherry Wu ©2019 | Carnegie Mellon Design School of Design 
                                </p>
                           </div>
-->
                       </div>
                   </footer>
                 </div>  
               </div>
               <div class="med-hide lrg-c2"></div>
            </div>
        </div> 
        <section class="rect">
            <svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1318 894">         <defs>
                    <style>.cls-1{fill:#000000;}</style>
                </defs>
                <title>rect</title>
                <rect class="cls-1" width="1318" height="894"/>
            </svg>
        </section>
        
        <script class="three">
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth /window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            //resize window
            window.addEventListener('resize', function(){
                var width = window.innerWidth;
                var height = window. innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width/height;
                camera.updateProjectionMatrix();
            });
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false;
           
            camera. position.z = 80;
            
            var geometry = new THREE.BoxGeometry(400,300,1);
            var cubeMaterials = [
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
                new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("img/artwork.jpg"), side: THREE.DoubleSide}),
            ];
            
            var cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
            var cube = new THREE.Mesh (geometry, cubeMaterial);
            cube.position.z = -500;
            scene.add(cube);
            
            //text
            var loader = new THREE.FontLoader();
            loader.load( 'fonts/Space_Grotesk_Regular.json', function ( font ) {
                var xMid, text;
                var color = 0x111111;
                var matDark = new THREE.LineBasicMaterial( {
                    color: color,
                    side: THREE.DoubleSide
                } );
                var matLite = new THREE.MeshBasicMaterial( {
                    color: color,
                    transparent: true,
                    opacity: 1,
                    side: THREE.DoubleSide
                } );
            
            
            //API REQUEST - BEGIN
            var urlString = "https://collectionapi.metmuseum.org/public/collection/v1/objects/436535";
            var request = new XMLHttpRequest();
            request.open('GET', urlString, true);
            request.onload = function() {
              // Begin accessing JSON data here
              var data = JSON.parse(this.response);
              if (request.status >= 200 && request.status < 400) {
                  console.log(data);
                    
                //TEXT STRING
                var message = data.title + "\n" + data.artistDisplayName;
                var shapes = font.generateShapes( message, 10 );
                var geometry = new THREE.ShapeBufferGeometry( shapes );
                geometry.computeBoundingBox();
                xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
//                geometry.translate( xMid, 0, 0 );
                // make shape ( N.B. edge view not visible )
                text = new THREE.Mesh( geometry, matLite );
                text.position.set(-460, -255, -690 ); 
//                text.rotation.y = THREE.Math.degToRad(90);
                scene.add( text );
                }
            };
            request.send();
            //PUT EVERYTHING INSIDE API REQUEST - END
                
                }); //end text load
                
            
        //frame
            //figure out painting size
            var textureLoader = new THREE.TextureLoader();
            var texture = textureLoader.load( "img/artwork.jpg", function ( texture ) {
                // tex and texture are the same in this example, but that might not always be the case
                console.log( texture.image.width, texture.image.height );
            } );
            
            // lower frame
            var lowerGeometry = new THREE.CubeGeometry(410,10,100);
            var lowerMaterial = new THREE.MeshLambertMaterial( {map: new THREE.TextureLoader().load('img/floor.png'), side: THREE.DoubleSide});
            var lowerCube = new THREE.Mesh (lowerGeometry, lowerMaterial);
            lowerCube.position.y = -150;
            lowerCube.position.z = -500;
            scene.add(lowerCube);
        
            // upper frame
            var upperGeometry = new THREE.CubeGeometry(410,10,100);
            var upperMaterial = new THREE.MeshLambertMaterial( {map: new THREE.TextureLoader().load('img/floor.png'), side: THREE.DoubleSide});
            var upperCube = new THREE.Mesh (upperGeometry, upperMaterial);
            upperCube.position.y = 150;
            upperCube.position.z = -500;
            scene.add(upperCube);
            
            
            //Left frame
            var leftFrameGeometry = new THREE.CubeGeometry(10,300,100);
            var leftFrameMaterial = new THREE.MeshLambertMaterial({map:new THREE.TextureLoader().load('img/floor.png'), side: THREE.DoubleSide});
            var leftFrameCube = new THREE.Mesh(leftFrameGeometry, leftFrameMaterial);
            leftFrameCube.position.x = -200;
            leftFrameCube.position.z = -500;
            scene.add(leftFrameCube);
            
            //Right frame
            var rightFrameGeometry = new THREE.CubeGeometry(10,300,100);
            var rightFrameMaterial = new THREE.MeshLambertMaterial({map:new THREE.TextureLoader().load('img/floor.png'), side: THREE.DoubleSide});
            var rightFrameCube = new THREE.Mesh(rightFrameGeometry, rightFrameMaterial);
            rightFrameCube.position.x =200;
            rightFrameCube.position.z = -500;
            scene.add(rightFrameCube);
            
        //room
            //right wall
            var rightWallGeometry = new THREE.CubeGeometry(10,600,1000);
            var wallMaterial = new THREE.MeshBasicMaterial({map:new THREE.TextureLoader().load('img/wall.png'), side:THREE.DoubleSide});
            var rightWallCube = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWallCube.position.x =500;
            rightWallCube.position.z = -200;
            scene.add(rightWallCube);
            
            //leftWall
            var leftWallGeometry = new THREE.CubeGeometry(10,600,1000);
            var leftWallCube = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWallCube.position.x =-500;
            leftWallCube.position.z = -200;
            scene.add(leftWallCube);
            
            //ceiling
            var ceilingGeometry = new THREE.CubeGeometry(1000,10,1000);
            var ceilingCube = new THREE.Mesh(ceilingGeometry, wallMaterial);
            ceilingCube.position.x = 0;
            ceilingCube.position.y = -300;
            ceilingCube.position.z = -200;
            scene.add(ceilingCube);
            
            //floor
            var floorGeometry = new THREE.CubeGeometry(1000,10,1000);
            var floorCube = new THREE.Mesh(floorGeometry, wallMaterial);
            floorCube.position.x = 0;
            floorCube.position.y = 300;
            floorCube.position.z = -200;
            scene.add(floorCube);
            
            //backwall
            var backWallGeometry = new THREE.CubeGeometry(1000,600,10);
            var backWallCube = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWallCube.position.x = 0;
            backWallCube.position.z = -700;
            scene.add(backWallCube);
            
            //front
            var backWallGeometry = new THREE.CubeGeometry(1000,600,10);
            var backWallCube = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWallCube.position.x = 0;
            backWallCube.position.z = 300;
            scene.add(backWallCube);
        
        //models
            //plant
            var loader = new THREE.GLTFLoader();
            loader.load( 'obj/indoor_plant/scene.gltf', function ( gltf ) {
                scene.add( gltf.scene );
                gltf.scene.scale.set(30, 30, 30);
                gltf.scene.position.set(300, -250, -200);
            } );
            
            //bench
            var loader = new THREE.GLTFLoader();
            loader.load( 'obj/leather_couch_black/scene.gltf', function ( gltf ) {
                scene.add( gltf.scene );
                gltf.scene.scale.set(50, 50, 50);
                gltf.scene.position.set(-20, -100, 120 );
                gltf.scene.rotation.y = THREE.Math.degToRad(180)
                gltf.scene.traverse((o) => {
                  if (o.isMesh) o.material.normalScale.y *= -1;
                });
            } );
            
        //light
            
            var spotLight = new THREE.SpotLight( 0xf0e0bc );
            spotLight.position.set( 0, -50, -50 );

            spotLight.decay = 1.2;
            spotLight.angle = 4;
            spotLight.intensity = 1.5;
            spotLight.distance = 300;

            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            spotLight.shadow.camera.near = 500;
            spotLight.shadow.camera.far = 500;
            spotLight.shadow.camera.fov = 30;
            scene.add( spotLight );
            
            
            var spotLight2 = new THREE.SpotLight( 0xf0e0bc );
            spotLight.position.set( 300, 100, 300 );

            spotLight2.decay = 1.2;
            spotLight2.angle = 4;
            spotLight2.intensity = 2;
            spotLight2.distance = 600;

            spotLight2.castShadow = true;
            spotLight2.shadow.mapSize.width = 1024;
            spotLight2.shadow.mapSize.height = 1024;
            spotLight2.shadow.camera.near = 500;
            spotLight2.shadow.camera.far = 500;
            spotLight2.shadow.camera.fov = 30;
            scene.add( spotLight2 );
            
            
            var ambientLight = new THREE.AmbientLight( 0xFFFFFF,0.99);
            scene.add(ambientLight);
            
            
            //game logic
            var update = function(){
//                cone.rotation.x += 0.01;
//                cone.rotation.y += 0.005;
//                cone.rotation.z += 0.005;
            };
            
            // draw scene
            var render = function(){
                renderer.render( scene, camera);
                renderer.gammaOutput = true;
                renderer.gammaFactor = 2.2;
            };
            
            // run game loop (update, render, repeat)
            var GameLoop = function(){
                requestAnimationFrame(GameLoop);
                
                update();
                render();
                
            };
            
            GameLoop(); 
        </script>
    </body>
</html>